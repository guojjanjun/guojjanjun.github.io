<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="true" />













<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="路人甲&#39;s Notes">
<meta property="og:url" content="https://guojjanjun.github.io/index.html">
<meta property="og:site_name" content="路人甲&#39;s Notes">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="路人甲&#39;s Notes">



  <link rel="alternate" href="/atom.xml" title="路人甲's Notes" type="application/atom+xml" />




  <link rel="canonical" href="https://guojjanjun.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>路人甲's Notes</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路人甲's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle"><a href="http://blog.51cto.com/guojuanjun">http://blog.51cto.com/guojuanjun</a> 不再更新</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2019/01/08/vmstat中的cs列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/vmstat中的cs列/" itemprop="url">
                  vmstat中的cs列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-08 14:08:42 / 修改时间：15:29:45" itemprop="dateCreated datePublished" datetime="2019-01-08T14:08:42+08:00">2019-01-08</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux将内存分为两部分：用户空间和内核空间。用户空间的程序无法访问内核空间的数据，反之依然，所以他们之间的指针无法直接使用。用户程序想访问内核空间，比如网络，文件系统的数据，则需要通过系统调用的方式进入内核空间。</p>
<p>在不同的空间时，CPU运行的环境是不同，然后有了上下文的概念。CPU总处于以下状态中的一种：<br>1）内核态，运行于进程上下文，内核代表进程运行于内核空间。<br>2）内核态，运行于中断上下文，内核代表硬件运行于内核空间。<br>3) 用户态, 运行于进程上文件的用户空间。</p>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><p>一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文：<br>1) 用户级上下文: 正文、数据、用户堆栈以及共享存储区；<br>2) 寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；<br>3) 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈等。</p>
<p>在进程调度的，系统需要将上面全部的信息进行切换，新的进程才可以运行。</p>
<p>####　模式切换<br>我们常说的系统调用，只是当前进程上下文从用户态进入内核态,只有寄存器上下文进行了切换。相对进程切换要简单很多。通过数据观察，模式切换不在vmstat的cs列统计中。<br><a href="http://blog.51cto.com/guojuanjun/1951816" target="_blank" rel="noopener">http://blog.51cto.com/guojuanjun/1951816</a></p>
<h4 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h4><p>CPU接收到硬件的中断信号, 则切换到中断上下文，进入内核态。由于中断处理程序只会运行在内核态，而且与进程无关。（中断处理程序不能睡眠，没有进程调度单元，睡了就没法唤醒了）。所以进程上下文切换到中断上下文时, 进程上下文的第一部分用户级上下文不需要切换。</p>
<p>那vmstat的cs是否包含中断上下文的切换呢,如图<br><img src="/2019/01/08/vmstat中的cs列/1.png" alt="logo"><br>通过这个数据观察, in(中断数)明显小于cs(上下文切换数)。 通常情况下，每次中断都会产生到中断上下文的切换，in不应该小于cs。反证可知，cs列不包括到中断产生的切换。</p>
<p>综上所述：vmstat中的cs列只包括进程上下文的切换。</p>
<p>进程调度程序只能运行在内核态,所以进程调度也只会发生在内核态:<br>1) 用户态进程无法实现主动调度。只有通过系统调用进入内核态，在系统调用处理完，返回用户态时，是一个调度点。这个时候会检测有没有设置NEED_RESCHED标志。<br>2) 若用户态进程没有系统调用，则通过中断处理程序返回时进行被动调度。<br>3) 内核进程可直接调用schedule()进行主动调度。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2019/01/01/KMP算法中Next数组的意义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/01/KMP算法中Next数组的意义/" itemprop="url">
                  KMP算法中Next数组的意义
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-01 16:52:47" itemprop="dateCreated datePublished" datetime="2019-01-01T16:52:47+08:00">2019-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-02 14:24:55" itemprop="dateModified" datetime="2019-01-02T14:24:55+08:00">2019-01-02</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>例如主串为a1,a2,a3,a4,a5,a6,…,an，模式串为b1,b2,b3,b4,b5,b6,…,bm。不失一般性，我们从主串头部字符开始匹配，a1=b1,a2=b2,a3=b3,a4=b4,a5=b5,a6!=b6，到达a6时匹配不成功, 如图所示：<br><img src="/2019/01/01/KMP算法中Next数组的意义/1.png" alt="logo"><br>按常规匹配算法，我们应该从a2开始重新匹配。假定此时可以匹配成功即a2=b1,a3=b2,a4=b3,a5=b4，…，如图所示：<br><img src="/2019/01/01/KMP算法中Next数组的意义/2.png" alt="logo"><br>按照前一次匹配所得的结论：a2=b2,a3=b3,a4=b4,a5=b5,可以推得b1=b2,b2=b3,b3=b4,b4=b5。即b1b2b3b4=b2b3b4b5相等。若模式串不满足这个条件，我们认为从a2开始对比是没有必要的，因为没有匹配成功的可能。<br>我们再假定从a2开始匹配没有成功，我们需要从a3开始匹配，假定此时匹配成功，即a3=b1,a4=b2,a5=b3,…，如图：<br><img src="/2019/01/01/KMP算法中Next数组的意义/3.png" alt="logo"><br>参照第一次匹配的结果，我们得出b1=b3,b2=b4,b3=b5即b1b2b3=b3b4b5。从模式的特征，可以帮助我们跳过那些不可能成功的匹配动作，提升算法效率。<br>我们总结下前面的结论：当第6个字符b6与主串匹配不成功时，我们的模式串应该右移几位去再次匹配。若模式串满足b1b2b3b4=b2b3b4b5，那我们只需移动一位。若字符串满足b1b2b3=b3b4b5，我们可以移动两位。同理可证b1b2=b4b5时，我们可以移动三位。即已完成匹配的子串b1b2b3b4b5的前缀与后缀的重合度的最大值决定了模式串移动的位数。重合度越大，移动的位数越小。模式串的移动距离决定了匹配失败的b6下应该和模式串中的哪个字符对比。而Next就是这种条件的表达方式。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/12/26/Linux中Cache与Buffer的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/Linux中Cache与Buffer的区别/" itemprop="url">
                  Linux中Cache与Buffer的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-26 20:32:44 / 修改时间：20:56:05" itemprop="dateCreated datePublished" datetime="2018-12-26T20:32:44+08:00">2018-12-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux中Free命令有一个Buffer/Cache很难理解。Buffer与Cache有什么区别? 通过dd操作,Vmstat数据输出来看，对于文件系统的读写对Cache的影响较大，而读写Raw设备对Buffer的影响较大，证明了大家认为的Cache为文件页缓存，而Buffer为IO块缓存。但是文件操作虽经过文件系统，但毕竟要从磁盘设备上读取，势必要经过块缓冲(Buffer)，为什么文件操作对Buffer 的影响不明显呢? 后来找到下面这篇文章（为防止信息丢失，我COPY过来了，请多包涵)。很多Unix是这样实现的，对于文件而言，一份数据会在Buffer与Cache中各缓存一份，简单但低效。后期Linux进行了统一,数据如果是块设备中的文件，则只缓存一份在PageCache中，而Buffer中不再缓存了。然而内核磁盘读写操作的仍然是Buffer，Buffer只是简单的指向Page Cache。</p>
<p>附原文:<br>The page cache caches pages of files to optimize file I/O. The buffer cache caches disk blocks to optimize block I/O. </p>
<p>Prior to Linux kernel version 2.4, the two caches were distinct: Files were in the page cache, disk blocks were in the buffer cache. Given that most files are represented by a filesystem on a disk, data was represented twice, once in each of the caches. Many Unix systems follow a similar pattern. </p>
<p>This is simple to implement, but with an obvious inelegance and inefficiency. Starting with Linux kernel version 2.4, the contents of the two caches were unified. The VM subsystem now drives I/O and it does so out of the page cache. If cached data has both a file and a block representation—as most data does—the buffer cache will simply point into the page cache; thus only one instance of the data is cached in memory. The page cache is what you picture when you think of a disk cache: It caches file data from a disk to make subsequent I/O faster. </p>
<p>The buffer cache remains, however, as the kernel still needs to perform block I/O in terms of blocks, not pages. As most blocks represent file data, most of the buffer cache is represented by the page cache. But a small amount of block data isn’t file backed—metadata and raw block I/O for example—and thus is solely represented by the buffer cache</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/12/24/NIO真空下的技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/24/NIO真空下的技术/" itemprop="url">
                  NIO真空下的技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-24 18:22:39 / 修改时间：19:19:26" itemprop="dateCreated datePublished" datetime="2018-12-24T18:22:39+08:00">2018-12-24</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NIO在使用过程中，有很多很多问题需要注意，甚至BUG需要规避。不是经验丰富的工程师团队，不建议从头构建NIO程序，最好采用Grizzly，Netty等开源框架。本文记录了经常遇到的几个小细节，一作备忘，二为增强理解。</p>
<h3 id="1-channel-close将cancel掉channel的所有SelectionKey"><a href="#1-channel-close将cancel掉channel的所有SelectionKey" class="headerlink" title="1. channel.close将cancel掉channel的所有SelectionKey"></a>1. channel.close将cancel掉channel的所有SelectionKey</h3><p>AbstractSelectableChannel维护一个SelectionKey数组，存储注册所得的所有SelectionKey，一旦channel.close，这里所有的SelectionKey将被cancel掉。</p>
<h3 id="2-只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException"><a href="#2-只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException" class="headerlink" title="2. 只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException"></a>2. 只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException</h3><p>比如FileChannel不可以改为非阻塞，所以也无法注册。</p>
<h3 id="3-一个Channel在同一个Selector上注册两次，返回同一个SelectionKey"><a href="#3-一个Channel在同一个Selector上注册两次，返回同一个SelectionKey" class="headerlink" title="3. 一个Channel在同一个Selector上注册两次，返回同一个SelectionKey"></a>3. 一个Channel在同一个Selector上注册两次，返回同一个SelectionKey</h3><p>Channel注册时，会被检查是否已在当前Selector上注册过,若是，则返回注册的SelectionKey。</p>
<h3 id="4-sk-interestOps操作与register操作在同一个线程"><a href="#4-sk-interestOps操作与register操作在同一个线程" class="headerlink" title="4. sk.interestOps操作与register操作在同一个线程"></a>4. sk.interestOps操作与register操作在同一个线程</h3><p>其实这不是必须的，Grizzly，Netty，和Tomcat都是这么写的，原先本人也误以为不在同一个线程会有问题，后来证明不是这样的。之所以这么写，是规避并发性能问题。AbstractSelectableChannel中有两把锁keyLock和regLock,interestOps与register操作会导致这两把锁的激烈竞争，所以都把这些操作交给注册该Channel的Reactor线程来完成。</p>
<h3 id="5-selector-selectedKeys中的SelectionKey要及早清除"><a href="#5-selector-selectedKeys中的SelectionKey要及早清除" class="headerlink" title="5. selector.selectedKeys中的SelectionKey要及早清除"></a>5. selector.selectedKeys中的SelectionKey要及早清除</h3><p>selectedKeys需要及时remove，否则后面select()将不阻塞，从而导致CPU 100%。</p>
<h3 id="6-不轻易注册WRITE事件"><a href="#6-不轻易注册WRITE事件" class="headerlink" title="6. 不轻易注册WRITE事件"></a>6. 不轻易注册WRITE事件</h3><p>因为可写事件来得太容易，select()将很难不阻塞，从而导致CPU 100%。</p>
<h3 id="7-selectionKey-cancel的延后性"><a href="#7-selectionKey-cancel的延后性" class="headerlink" title="7. selectionKey.cancel的延后性"></a>7. selectionKey.cancel的延后性</h3><p>取消Key只有在下一次select操作之后才会从key set中清除。</p>
<h3 id="8-select（）操作之前的wakeup将导致下一次的select（）不阻塞。"><a href="#8-select（）操作之前的wakeup将导致下一次的select（）不阻塞。" class="headerlink" title="8. select（）操作之前的wakeup将导致下一次的select（）不阻塞。"></a>8. select（）操作之前的wakeup将导致下一次的select（）不阻塞。</h3>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/12/19/getOutputStream() has already been called for this response的来路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/getOutputStream() has already been called for this response的来路/" itemprop="url">
                  getOutputStream() has already been called for this response的来路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-19 16:24:37" itemprop="dateCreated datePublished" datetime="2018-12-19T16:24:37+08:00">2018-12-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-21 13:24:43" itemprop="dateModified" datetime="2018-12-21T13:24:43+08:00">2018-12-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>除了上篇的response has been committed，另一个常见的异常getOutputStream() has alreadybeen called for this response 或 getWriter() has already been called for this response。这类异常并非Tomcat专有的，在weblogic中是为strict servlet API: cannot call getWriter() after getOutputStream 或 strict servlet API: cannot call getOutputStream() after getWriter().</p>
<p>意思就是调用了getWriter之后，不能再调用getOutputStream, 反之亦然。getWriter和getOutputStream都是servlet引擎用来向响应报文中写入数据的方法。那为什么要限制同时使用呢? </p>
<p>getWriter()方法返回是PrintWriter对象，PrintWriter用来写入字符或字符串。getOutputStream()返回ServletOutputStream，其接口为OutputStream，所以getOutputStream()方法用来写入字节流。</p>
<p>getWriter和getOutputStream就像向响应报文中输入数据的管子，而且两个管子中的数据格式不一样。如果两个管子同时向响应报文中灌入数据，那数据是不是就乱了呢？ 所以中间件安排他俩互斥使用。</p>
<p>既然PrintWriter用来写入字符或字符串，那把PrintWriter写入的字符串转换成字节流不就可以同时用了。其实PrintWriter写入数据的时候有可能响应字符集还没有确定，你无法知道应该用哪个字符集去转换。(Tomcat提供了ENFORCE_ENCODING_IN_GET_WRITER参数)。具体其他的原因，只能咨询规范的作者了。在Servlet2.5规范SRV.15.2.22节提到:Either this method or getWriter() may becalled to write the body, not both.</p>
<p>什么情况下出现前面提到的异常，一般在我们需要输出一种特殊格式的响应内容时会出现。比如验证码，导出文件等。大多程序员会把这些业务放在Jsp中，然后通过response.getOutputStream().write()输出数据。而Jsp页面中的可能含有html内容，即使只是一个空格或者换行。这些内容是通过out.write输出的, 这个out其实就response.getWriter()的值。这样就会在你不经意中被调用response.getWriter()，可能位于response.getOutputStream()调用之前，也可能在之后。无论如何，异常是跑不了啦。</p>
<p>解决这类问题的方法当前很简单，就是隐藏的response.getWriter()的调用:</p>
<ol>
<li>使用Servlet输出验证码，导出文件。</li>
<li>如果确要用JSP文件，最好的办法看编译后的java文件，有没有out.write操作。有的话，检查是JSP哪一行引起的，删除即可。<br>大多数情况出现这个异常，并没影响正常业务。其实异常是后一个get调用引起的，而且这个调用非常大的机率是不需要的，调用他的时候响应报文大概已经在去向客户端的路上了。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/12/06/Maven使用过程中的几个细节/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Maven使用过程中的几个细节/" itemprop="url">
                  Maven使用过程中的几个细节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 14:17:22" itemprop="dateCreated datePublished" datetime="2018-12-06T14:17:22+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-14 17:14:25" itemprop="dateModified" datetime="2019-01-14T17:14:25+08:00">2019-01-14</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Settings-xml的生效问题"><a href="#1-Settings-xml的生效问题" class="headerlink" title="1. Settings.xml的生效问题"></a>1. Settings.xml的生效问题</h3><p>maven共有两个settings.xml:<br>全局配置: ${M2_HOME}/conf/settings.xml<br>用户配置: ${user.home}/.m2/settings.xml<br>maven使用两者的合并信息，用户配置的优先级高于全局配置。其有mvn -s(–settings)可以修改用户配置.</p>
<h3 id="2-多个Profile的生效问题"><a href="#2-多个Profile的生效问题" class="headerlink" title="2. 多个Profile的生效问题"></a>2. 多个Profile的生效问题</h3><p>Profile根据环境条件被激活:<br>  1) <code>&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</code><br>  2) <code>&lt;activeProfile&gt;profileName&lt;/activeProfile&gt;</code><br>  3) ..<br>如果多个Profile同时激活，则Profile会合并，相同的配置则后定义的Profile优先级比较高。与active的顺序无关。</p>
<h3 id="3-repository的搜索顺序"><a href="#3-repository的搜索顺序" class="headerlink" title="3. repository的搜索顺序"></a>3. repository的搜索顺序</h3><p>   repository分两类：本地仓库和远程仓库。远程仓库包括全局仓库，项目仓库和中央仓库。搜索顺序如下：<br>  1) 本地仓库: 就是本地的缓存目录，一般~/m2/repository<br>  2) 全局仓库: setting文件profile中配置的仓库。<br>  3）项目仓库: 项目pom.xml中profile配置的仓库。<br>  4）项目仓库: 项目pom.xml中配置的仓库。<br>  5) 中央仓库：就是central仓库</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/12/05/什么是response has been committed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/什么是response has been committed/" itemprop="url">
                  什么是response has been committed
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 15:15:07" itemprop="dateCreated datePublished" datetime="2018-12-05T15:15:07+08:00">2018-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-21 13:40:10" itemprop="dateModified" datetime="2018-12-21T13:40:10+08:00">2018-12-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Tomcat或其他中间件产品上，有时或突然跳出一个response has been committed的异常。网上也有很多解决这个问题的攻略。为什么很多，或许写答案的人也不知道为什么这个方法解决了这个问题，而是各种尝试之后, 终于解决了。(边何人初见月，江月何年初照人)<br>什么叫response has been committed？ 数据库有已提交的概念，表示相关事务已完成，可能数据并没有写入数据磁盘，而是位于redo日志中，无论怎么，事务已成功，即使此时掉电，也不会丢失更新。已提交的事务还可以撤回吗？当然不可以。(更多可了解redo与undo的区别)。</p>
<p>而Tomcat对于Response的已提交也是一样，表示Response已成即定事实，撤回不了了。Tomcat在这个response有任意一个字符发送到网络时，会标识response已提交。为什么呢？数据已经发出去，再也无法中断/撤回他了。所谓覆水难收就是这个意思。</p>
<p>我们看response has been committed一般发生在什么时候:<br>1) Java.lang.IllegalStateException: Cannot call sendRedirect() after the response has been committed sendRedirect<br>   什么意思呢? 当我想放弃当前的响应内容，回复一个304的响应让客户端重新请求。但这里因为发送缓冲区不足，Tomcat已将原先准备好的一些数据发送出去了,当然响应头会被首先发出。Tomcat是告诉你：哥们，不好意思，状态为200的响应我已经发送出去了。<br>2）Cannot forward after response has been committed<br>   同1)一样，你想抛弃你当前的响应(response)，forward到一个新的sevlet去响应当前的请求，Tomcat告诉你:你的响应已经发出去了, 撤不回来了。</p>
<p>3) sendError等。<br>   sendError意欲改变响应状态码。设想这时状态码已经在网络链路间跋山涉水，奔向客户端，打个电话让他回来吗？</p>
<p>明白了问题产生的原因，更容易寻找解决的方法。为什么Tomcat会在我们决定sendRedirect时已经将response的数据发出去？ 除了代码可能作了flush（将数据写入网络）操作，也有可能发送缓冲区较小，Tomcat只能将原有的数据写出网络。一个治标的方法，就是将缓冲区调大。治本的方法当然是：写代码要有计划。不然何至覆水难收? </p>
<p>更多细节参考 Servlet4 规范-5.1 Buffering </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/12/04/istio中的流量分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/istio中的流量分析/" itemprop="url">
                  Istio流量分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-04 16:26:20" itemprop="dateCreated datePublished" datetime="2018-12-04T16:26:20+08:00">2018-12-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-02 13:46:06" itemprop="dateModified" datetime="2019-01-02T13:46:06+08:00">2019-01-02</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注： 文中示例信息来自istio官方book示例.</p>
<p>istio中的边车代理envoy会拦截到两类流量:<br>1) 入流量: 其他Pod访问当前Pod中业务服务的流量。入流量访问的集群以inbound开头命名:<br>   inbound|9080|v1|ratings.default.svc.cluster.local<br>2) 出流量: 当前Pod中业务服务访问其他服务的流量,包括其他POD中的业务服务和istio系统相关的服务。入流量访问的集群命名以outbound开头: outbound|9080|v1|ratings.default.svc.cluster.local</p>
<p>入流量的上游集群比较简单，一般只有一个：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"hosts": [</span><br><span class="line">               &#123;</span><br><span class="line">                        <span class="attr">"socket_address"</span>: &#123;</span><br><span class="line">                        <span class="attr">"address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">                        <span class="attr">"port_value"</span>: <span class="number">9080</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">         ]</span><br></pre></td></tr></table></figure></p>
<p>这个Endpoint(127.0.0.1:9080)指向本地服务。出流量的上游集群包括所有的服务集群，因为当前POD的本地服务有访问任何服务的可能。</p>
<p>Envoy代理拦截到出流量之后,会根据被访问service的域名，URL等相关信息定位到特定的路由，然后到特定的集群，再按集群内部的负载算法获取特定的Endpoint地址，将流量发送给这个Endpoint。流量图大体如下：<br><img src="/2018/12/04/istio中的流量分析/in_out.png" alt="logo"><br>这个复杂的过程中,有两个重要的参数:<br>1) litener.use_original_dst:<br>如果采有iptables重定向连接, 那么envoy接受连接的监听端口与请求连接的原始目的地址是不同的。如果listener该属性设置为true，该listener将接收到的连接转交给符合请求原始地址的Listener。(透明代理获取原始地址?)由新的listener接受和处理该连接请求。前一个Listener相当于只分发连接。在istio中，这个Listener命名为命virtual。到达envoy的流量统一重定向到virtual listener中(监听地址为0.0.0.0:15001)，由它来选择合适的Listener处理流量。</p>
<p>2) litener.bind_to_port<br>这个属性在api-v2中找不到了，也没找到新替代者的说明。在istio 1.0版本中仍然使用他，但标记已过期。该属性表示Listener是否绑定主机端口。那么不绑定的端口的Listener，如何接受流量？是由标识use_original_dst的Listener(上文中的virtual Listener)接受流量，并转发给他。0.0.0.0_9080和10.244.2.20_9080都是bind_to_port为false的Listener,等待virtual listener分发的流量。0.0.0.0_9080接收所有9080端口的出流量，10.244.2.20_9080接受入流量。<br><img src="/2018/12/04/istio中的流量分析/netstat.png" alt="logo"><br>9080本地服务的端口，15000是envoy代理的管理端口，0.0.0.0:15001就是virtual listener的监听地址，envoy用来接收流量。在evnoy的配置中看到其他listener都没有绑定端口。</p>
<p>Note:<br>获取envoy全配置的方法:<br>kubectl exec productpage-v1-f5fcbd489-s7tfz -c istio-proxy – curl <a href="http://127.0.0.1:15000/config_dump" target="_blank" rel="noopener">http://127.0.0.1:15000/config_dump</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/11/26/CPU主频与MIPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/26/CPU主频与MIPS/" itemprop="url">
                  CPU主频与MIPS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-26 16:52:47" itemprop="dateCreated datePublished" datetime="2018-11-26T16:52:47+08:00">2018-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-21 13:37:41" itemprop="dateModified" datetime="2018-12-21T13:37:41+08:00">2018-12-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在一台龙芯CPU的机器上发现一个BogoMIPS参数，刚好位于CPU MHZ参数的上面:<br>BogoMIPS: 1593.34<br>cpu MHZ :  799.58<br>查看其他机器如redhat，ft等都有这两个参数,只是不放在一起，所认平时很难注意到。<br>MIPS Google描述为：Million Instructions Per Second，即每秒执行百万(M)指令数。这就奇怪了，当前CPU的主频才799.58MHZ，却可以每秒执行1593.34M个指令。相当每个时钟周期执行两个指令。</p>
<p>时钟周期是CPU主频的倒数，799.58MHZ表示每秒运行799.58百万个时钟周期. 而每执一个计算机指令都需要1至几十个时钟周期。一个指令的执行包括以下步骤：<br>1）指令预取<br>2）指令解码<br>3）执行<br>4）内存访问<br>5) 寄存器写回<br>最后两步是可选的，取决于指令本身。这里每一步都需要至少一个时钟周期来完成。那么一个指令至少需要3个时钟周期来完成? 这里CPU通过流水线技术同时执行不同指令的不同部分，提高CPU的吞吐量。上面的每一步都由CPU的一个功能组件来完成,当指令解码组件执行指令A的指令解码动作时，指令预取组件可以执行指令B的指令预取部分。最理想情况下，一个指令只需要一个时间周期。但仍然不能2倍主频？</p>
<p>部分资料提到指令宽度的概念，即上面所说的每一个功能单元组件有多个，一般3-4个。他们可以同时执行。这样最理想情况，一个指令只需要一个1/3或1/4个时间周期了。如果是这样的话，上面的情况就可以解释了。另外业内经常提到的IPC(或CPI)，即每指令周期数，在这里应该就是: CPI = MHZ/MIPS。从上面分析来看，CPI是可以小于1的。这里只是一个合理解释，不一定正确，期待指正。<br>参考：<br><a href="https://courses.cs.washington.edu/courses/cse471/07sp/lectures/Lecture3.pdf" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse471/07sp/lectures/Lecture3.pdf</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojjanjun.github.io/2018/11/22/面向对象众生相/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="路人甲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路人甲's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/面向对象众生相/" itemprop="url">
                  面向对象众生相
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-22 19:35:36" itemprop="dateCreated datePublished" datetime="2018-11-22T19:35:36+08:00">2018-11-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-21 13:31:13" itemprop="dateModified" datetime="2018-12-21T13:31:13+08:00">2018-12-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>编程语言层出不穷，面向对象的样式各有特色。各种意料之外的编程模型，惊呼”哦,面象对象还可以这样玩”。其中比较容易理解的是Java和C++的对象模型，两者之间区分度也很小: Java的成员函数只能在类内定义, 而C++的成员函数可以类内声明，类外定义。(当然区分并不止这么点)。</p>
<p>后起之秀Go语言对面向对象有了新的定义: 面向对象就是将要处理的数据跟函数进行绑定的方法。</p>
<h3 id="定义数据类型："><a href="#定义数据类型：" class="headerlink" title="定义数据类型："></a>定义数据类型：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Dog struct&#123;</span><br><span class="line">   name string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绑定函数："><a href="#绑定函数：" class="headerlink" title="绑定函数："></a>绑定函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (dog Dog) move() &#123;</span><br><span class="line">   fmt.Println(dog.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用函数："><a href="#调用函数：" class="headerlink" title="调用函数："></a>调用函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   var aDog Dog</span><br><span class="line">   aDog.move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要为函数指定接收者,即完成了数据与函数的绑定,而且接收者可以是基础类型,比如int等。可以做到一切皆对象。自由绑定成员函数，使项目功能扩展极其方便。</p>
<p>起初笔者并不喜欢Javascript面向对象的方法，go的出现再次重申了Javascript面向对象的终极地位。且看Javascript几种创建对象的神技:</p>
<h3 id="方法一：通过Object对象"><a href="#方法一：通过Object对象" class="headerlink" title="方法一：通过Object对象"></a>方法一：通过Object对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var box = <span class="keyword">new</span> Object();</span><br><span class="line">box.name = <span class="string">'Lee'</span>;</span><br><span class="line">box.getName = function () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方式与go倒有几分相似，不过Javascript不但能绑定函数，还可以增加数据成员。go语言并无出其右。</p>
<h3 id="方法二-构造函数式："><a href="#方法二-构造函数式：" class="headerlink" title="方法二: 构造函数式："></a>方法二: 构造函数式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Box</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.getName = function () &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var box1 = <span class="keyword">new</span> Box(<span class="string">'Lee'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="方法三：原型模式"><a href="#方法三：原型模式" class="headerlink" title="方法三：原型模式"></a>方法三：原型模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Box.prototype.name = <span class="string">'Lee'</span>;</span><br><span class="line">Box.prototype.getName = function () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法四,五…, 招式只局限于你的想象力。为什么Javascript要搞这么复杂, 搞这么复杂…?</p>
<p>其实是Javascript玩了个七十二变的戏法, 让我们产生了错觉。下面来拆解Javascript这种怪异的OOP玩法？ </p>
<p>对于方法一, Object也是一个函数(typeof Object == function), 这个函数是Javascript内置的，不需要程序员重新定义。那它和方法二之间的相同基因就不难理解了。</p>
<p>方法一中Javascript可以为对象本身增加属性和绑定方法。方法二也是一样, 而this就是这个对象, 函数为this对象增加属性和绑定方法。再看方法三的模式, 同方法一、二并无不同, 只不过Box.prototype才是这个对象。</p>
<p>其实Javascript中每一个函数都有一个本尊(原型)对象，函数用这个对象作为创建新对象的基础对象, 我们把这个对象看成是具有变化能力的齐天大圣, 新对象都是大圣变化而来。这个本尊对象就是funcation_name.prototype。</p>
<p>而函数就是这位本尊的变身大法，也就是克隆出新对象的构造器, 启动变身大法（new 函数)本尊就会变成想要的模样。这样方法二就容易理解了。</p>
<p>对于方法三, Box.prototype就是Box函数的本尊，改变Box.prototype：Box.prototype.name = ‘Lee’。相当于改变了函数的本尊(原型)对象（由原来的孙悟空变成猪悟能), 构造器的当然就是在这个新本尊的基础上构建新对象。</p>
<p>更有意思的，方法二可以直接作为普通函数调用: Box(‘Lee’)，也可以作为构造函数调用 var box1 = new Box(‘Lee’)。函数里的this代表的对象什么不同呢？作为构造函数时，前面已经说过，这里不再重述。但作为普通函数，this却是当前Window对象，这里相当于window.Box(“Lee”)，即它是作为Window的成员函数而存在的。Javascript中所有的全局函数和对象都属于Window对象的属性和方法。</p>
<p>网上有很多Javascript面向对象的方法变体，用此方法，即可解疑惑。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">路人甲</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">路人甲</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

  

</body>
</html>
