<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>路人甲&#39;s Notes</title>
  
  <subtitle>&lt;a href=&quot;http://blog.51cto.com/guojuanjun&quot;&gt;http://blog.51cto.com/guojuanjun&lt;/a&gt; 不再更新</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://guojjanjun.github.io/"/>
  <updated>2018-12-26T12:51:08.211Z</updated>
  <id>https://guojjanjun.github.io/</id>
  
  <author>
    <name>路人甲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux中Cache与Buffer的区别</title>
    <link href="https://guojjanjun.github.io/2018/12/26/Linux%E4%B8%ADCache%E4%B8%8EBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://guojjanjun.github.io/2018/12/26/Linux中Cache与Buffer的区别/</id>
    <published>2018-12-26T12:32:44.000Z</published>
    <updated>2018-12-26T12:51:08.211Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中Free命令有一个Buffer/Cache很难理解。Buffer与Cache有什么区别? 通过dd操作,Vmstat数据输出来看，对于文件系统的读写对Cache的影响较大，而读写Raw设备对Buffer的影响较大，证明了大家认为的Cache为文件页缓存，而Buffer为IO块缓存。但是文件操作虽经过文件系统，但毕竟要从磁盘设备上读取，势必要经过块缓冲(Buffer)，为什么文件操作对Buffer 的影响不明显呢? 后来找到下面这篇文章（为防止信息丢失，我COPY过来了，请多包涵)。很多Unix是这样实现，对于文件而言，一份数据会在Buffer与Cache中各缓存一份，简单但低效。后期Linux进行了统一,数据如果是块设备中的文件，则只缓存一份在PageCache中，而Buffer中不再缓冲了。内核磁盘读写操作的仍然是Buffer，但Buffer只是简单的指向Page Cache。这也是实验文件操作过程中Page Cache快速增大，而Buffer也增长的原因。</p><p>附原文:<br>The page cache caches pages of files to optimize file I/O. The buffer cache caches disk blocks to optimize block I/O. </p><p>Prior to Linux kernel version 2.4, the two caches were distinct: Files were in the page cache, disk blocks were in the buffer cache. Given that most files are represented by a filesystem on a disk, data was represented twice, once in each of the caches. Many Unix systems follow a similar pattern. </p><p>This is simple to implement, but with an obvious inelegance and inefficiency. Starting with Linux kernel version 2.4, the contents of the two caches were unified. The VM subsystem now drives I/O and it does so out of the page cache. If cached data has both a file and a block representation—as most data does—the buffer cache will simply point into the page cache; thus only one instance of the data is cached in memory. The page cache is what you picture when you think of a disk cache: It caches file data from a disk to make subsequent I/O faster. </p><p>The buffer cache remains, however, as the kernel still needs to perform block I/O in terms of blocks, not pages. As most blocks represent file data, most of the buffer cache is represented by the page cache. But a small amount of block data isn’t file backed—metadata and raw block I/O for example—and thus is solely represented by the buffer cache</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux中Free命令有一个Buffer/Cache很难理解。Buffer与Cache有什么区别? 通过dd操作,Vmstat数据输出来看，对于文件系统的读写对Cache的影响较大，而读写Raw设备对Buffer的影响较大，证明了大家认为的Cache为文件页缓存，而Buf
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NIO真空下的技术</title>
    <link href="https://guojjanjun.github.io/2018/12/24/NIO%E7%9C%9F%E7%A9%BA%E4%B8%8B%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <id>https://guojjanjun.github.io/2018/12/24/NIO真空下的技术/</id>
    <published>2018-12-24T10:22:39.000Z</published>
    <updated>2018-12-24T11:19:26.321Z</updated>
    
    <content type="html"><![CDATA[<p>NIO在使用过程中，有很多很多问题需要注意，甚至BUG需要规避。不是经验丰富的工程师团队，不建议从头构建NIO程序，最好采用Grizzly，Netty等开源框架。本文记录了经常遇到的几个小细节，一作备忘，二为增强理解。</p><h3 id="1-channel-close将cancel掉channel的所有SelectionKey"><a href="#1-channel-close将cancel掉channel的所有SelectionKey" class="headerlink" title="1. channel.close将cancel掉channel的所有SelectionKey"></a>1. channel.close将cancel掉channel的所有SelectionKey</h3><p>AbstractSelectableChannel维护一个SelectionKey数组，存储注册所得的所有SelectionKey，一旦channel.close，这里所有的SelectionKey将被cancel掉。</p><h3 id="2-只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException"><a href="#2-只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException" class="headerlink" title="2. 只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException"></a>2. 只有非阻塞Channel才能注册，否则会报IllegalBlockingModeException</h3><p>比如FileChannel不可以改为非阻塞，所以也无法注册。</p><h3 id="3-一个Channel在同一个Selector上注册两次，返回同一个SelectionKey"><a href="#3-一个Channel在同一个Selector上注册两次，返回同一个SelectionKey" class="headerlink" title="3. 一个Channel在同一个Selector上注册两次，返回同一个SelectionKey"></a>3. 一个Channel在同一个Selector上注册两次，返回同一个SelectionKey</h3><p>Channel注册时，会被检查是否已在当前Selector上注册过,若是，则返回注册的SelectionKey。</p><h3 id="4-sk-interestOps操作与register操作在同一个线程"><a href="#4-sk-interestOps操作与register操作在同一个线程" class="headerlink" title="4. sk.interestOps操作与register操作在同一个线程"></a>4. sk.interestOps操作与register操作在同一个线程</h3><p>其实这不是必须的，Grizzly，Netty，和Tomcat都是这么写的，原先本人也误以为不在同一个线程会有问题，后来证明不是这样的。之所以这么写，是规避并发性能问题。AbstractSelectableChannel中有两把锁keyLock和regLock,interestOps与register操作会导致这两把锁的激烈竞争，所以都把这些操作交给注册该Channel的Reactor线程来完成。</p><h3 id="5-selector-selectedKeys中的SelectionKey要及早清除"><a href="#5-selector-selectedKeys中的SelectionKey要及早清除" class="headerlink" title="5. selector.selectedKeys中的SelectionKey要及早清除"></a>5. selector.selectedKeys中的SelectionKey要及早清除</h3><p>selectedKeys需要及时remove，否则后面select()将不阻塞，从而导致CPU 100%。</p><h3 id="6-不轻易注册WRITE事件"><a href="#6-不轻易注册WRITE事件" class="headerlink" title="6. 不轻易注册WRITE事件"></a>6. 不轻易注册WRITE事件</h3><p>因为可写事件来得太容易，select()将很难不阻塞，从而导致CPU 100%。</p><h3 id="7-selectionKey-cancel的延后性"><a href="#7-selectionKey-cancel的延后性" class="headerlink" title="7. selectionKey.cancel的延后性"></a>7. selectionKey.cancel的延后性</h3><p>取消Key只有在下一次select操作之后才会从key set中清除。</p><h3 id="8-select（）操作之前的wakeup将导致下一次的select（）不阻塞。"><a href="#8-select（）操作之前的wakeup将导致下一次的select（）不阻塞。" class="headerlink" title="8. select（）操作之前的wakeup将导致下一次的select（）不阻塞。"></a>8. select（）操作之前的wakeup将导致下一次的select（）不阻塞。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NIO在使用过程中，有很多很多问题需要注意，甚至BUG需要规避。不是经验丰富的工程师团队，不建议从头构建NIO程序，最好采用Grizzly，Netty等开源框架。本文记录了经常遇到的几个小细节，一作备忘，二为增强理解。&lt;/p&gt;
&lt;h3 id=&quot;1-channel-close
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>getOutputStream() has already been called for this response的来路</title>
    <link href="https://guojjanjun.github.io/2018/12/19/getOutputStream()%20has%20already%20been%20called%20for%20this%20response%E7%9A%84%E6%9D%A5%E8%B7%AF/"/>
    <id>https://guojjanjun.github.io/2018/12/19/getOutputStream() has already been called for this response的来路/</id>
    <published>2018-12-19T08:24:37.000Z</published>
    <updated>2018-12-21T05:24:43.847Z</updated>
    
    <content type="html"><![CDATA[<p>除了上篇的response has been committed，另一个常见的异常getOutputStream() has alreadybeen called for this response 或 getWriter() has already been called for this response。这类异常并非Tomcat专有的，在weblogic中是为strict servlet API: cannot call getWriter() after getOutputStream 或 strict servlet API: cannot call getOutputStream() after getWriter().</p><p>意思就是调用了getWriter之后，不能再调用getOutputStream, 反之亦然。getWriter和getOutputStream都是servlet引擎用来向响应报文中写入数据的方法。那为什么要限制同时使用呢? </p><p>getWriter()方法返回是PrintWriter对象，PrintWriter用来写入字符或字符串。getOutputStream()返回ServletOutputStream，其接口为OutputStream，所以getOutputStream()方法用来写入字节流。</p><p>getWriter和getOutputStream就像向响应报文中输入数据的管子，而且两个管子中的数据格式不一样。如果两个管子同时向响应报文中灌入数据，那数据是不是就乱了呢？ 所以中间件安排他俩互斥使用。</p><p>既然PrintWriter用来写入字符或字符串，那把PrintWriter写入的字符串转换成字节流不就可以同时用了。其实PrintWriter写入数据的时候有可能响应字符集还没有确定，你无法知道应该用哪个字符集去转换。(Tomcat提供了ENFORCE_ENCODING_IN_GET_WRITER参数)。具体其他的原因，只能咨询规范的作者了。在Servlet2.5规范SRV.15.2.22节提到:Either this method or getWriter() may becalled to write the body, not both.</p><p>什么情况下出现前面提到的异常，一般在我们需要输出一种特殊格式的响应内容时会出现。比如验证码，导出文件等。大多程序员会把这些业务放在Jsp中，然后通过response.getOutputStream().write()输出数据。而Jsp页面中的可能含有html内容，即使只是一个空格或者换行。这些内容是通过out.write输出的, 这个out其实就response.getWriter()的值。这样就会在你不经意中被调用response.getWriter()，可能位于response.getOutputStream()调用之前，也可能在之后。无论如何，异常是跑不了啦。</p><p>解决这类问题的方法当前很简单，就是隐藏的response.getWriter()的调用:</p><ol><li>使用Servlet输出验证码，导出文件。</li><li>如果确要用JSP文件，最好的办法看编译后的java文件，有没有out.write操作。有的话，检查是JSP哪一行引起的，删除即可。<br>大多数情况出现这个异常，并没影响正常业务。其实异常是后一个get调用引起的，而且这个调用非常大的机率是不需要的，调用他的时候响应报文大概已经在去向客户端的路上了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除了上篇的response has been committed，另一个常见的异常getOutputStream() has alreadybeen called for this response 或 getWriter() has already been called
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven使用过程中的几个细节</title>
    <link href="https://guojjanjun.github.io/2018/12/06/Maven%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82/"/>
    <id>https://guojjanjun.github.io/2018/12/06/Maven使用过程中的几个细节/</id>
    <published>2018-12-06T06:17:22.000Z</published>
    <updated>2018-12-06T07:48:03.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Settings-xml的生效问题"><a href="#1-Settings-xml的生效问题" class="headerlink" title="1. Settings.xml的生效问题"></a>1. Settings.xml的生效问题</h3><p>maven共有两个settings.xml:<br>全局配置: ${M2_HOME}/conf/settings.xml<br>用户配置: ${user.home}/.m2/settings.xml<br>maven使用两者的合并信息，用户配置的优先级高于全局配置。其有mvn -s(–settings)可以修改用户配置.</p><h3 id="2-多个Profile的生效问题"><a href="#2-多个Profile的生效问题" class="headerlink" title="2. 多个Profile的生效问题"></a>2. 多个Profile的生效问题</h3><p>Profile根据环境条件被激活:<br>  1) <code>&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</code><br>  2) <code>&lt;activeProfile&gt;profileName&lt;/activeProfile&gt;</code><br>  3) ..<br>如果多个Profile同时激活，则Profile会合并，相同的配置则后定义的Profile优先级比较高。与active的顺序无关。</p><h3 id="3-repository的搜索顺序"><a href="#3-repository的搜索顺序" class="headerlink" title="3. repository的搜索顺序"></a>3. repository的搜索顺序</h3><p>   repository分两类：本地仓库和远程仓库。远程仓库包括全局仓库，项目仓库和中央仓库。搜索顺序如下：<br>  1) 本地仓库: 就是本地的缓存目录，一般~/m2/repository<br>  2) 全局仓库: setting文件profile中配置的仓库。<br>  3）项目仓库: 项目pom.xml中配置的仓库。<br>  3) 中央仓库：就是central仓库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Settings-xml的生效问题&quot;&gt;&lt;a href=&quot;#1-Settings-xml的生效问题&quot; class=&quot;headerlink&quot; title=&quot;1. Settings.xml的生效问题&quot;&gt;&lt;/a&gt;1. Settings.xml的生效问题&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>什么是response has been committed</title>
    <link href="https://guojjanjun.github.io/2018/12/05/%E4%BB%80%E4%B9%88%E6%98%AFresponse%20has%20been%20committed/"/>
    <id>https://guojjanjun.github.io/2018/12/05/什么是response has been committed/</id>
    <published>2018-12-05T07:15:07.000Z</published>
    <updated>2018-12-21T05:40:10.617Z</updated>
    
    <content type="html"><![CDATA[<p>在Tomcat或其他中间件产品上，有时或突然跳出一个response has been committed的异常。网上也有很多解决这个问题的攻略。为什么很多，或许写答案的人也不知道为什么这个方法解决了这个问题，而是各种尝试之后, 终于解决了。(边何人初见月，江月何年初照人)<br>什么叫response has been committed？ 数据库有已提交的概念，表示相关事务已完成，可能数据并没有写入数据磁盘，而是位于redo日志中，无论怎么，事务已成功，即使此时掉电，也不会丢失更新。已提交的事务还可以撤回吗？当然不可以。(更多可了解redo与undo的区别)。</p><p>而Tomcat对于Response的已提交也是一样，表示Response已成即定事实，撤回不了了。Tomcat在这个response有任意一个字符发送到网络时，会标识response已提交。为什么呢？数据已经发出去，再也无法中断/撤回他了。所谓覆水难收就是这个意思。</p><p>我们看response has been committed一般发生在什么时候:<br>1) Java.lang.IllegalStateException: Cannot call sendRedirect() after the response has been committed sendRedirect<br>   什么意思呢? 当我想放弃当前的响应内容，回复一个304的响应让客户端重新请求。但这里因为发送缓冲区不足，Tomcat已将原先准备好的一些数据发送出去了,当然响应头会被首先发出。Tomcat是告诉你：哥们，不好意思，状态为200的响应我已经发送出去了。<br>2）Cannot forward after response has been committed<br>   同1)一样，你想抛弃你当前的响应(response)，forward到一个新的sevlet去响应当前的请求，Tomcat告诉你:你的响应已经发出去了, 撤不回来了。</p><p>3) sendError等。<br>   sendError意欲改变响应状态码。设想这时状态码已经在网络链路间跋山涉水，奔向客户端，打个电话让他回来吗？</p><p>明白了问题产生的原因，更容易寻找解决的方法。为什么Tomcat会在我们决定sendRedirect时已经将response的数据发出去？ 除了代码可能作了flush（将数据写入网络）操作，也有可能发送缓冲区较小，Tomcat只能将原有的数据写出网络。一个治标的方法，就是将缓冲区调大。治本的方法当然是：写代码要有计划。不然何至覆水难收? </p><p>更多细节参考 Servlet4 规范-5.1 Buffering </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Tomcat或其他中间件产品上，有时或突然跳出一个response has been committed的异常。网上也有很多解决这个问题的攻略。为什么很多，或许写答案的人也不知道为什么这个方法解决了这个问题，而是各种尝试之后, 终于解决了。(边何人初见月，江月何年初照人)
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Istio流量分析</title>
    <link href="https://guojjanjun.github.io/2018/12/04/istio%E4%B8%AD%E7%9A%84%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>https://guojjanjun.github.io/2018/12/04/istio中的流量分析/</id>
    <published>2018-12-04T08:26:20.000Z</published>
    <updated>2018-12-21T05:21:56.174Z</updated>
    
    <content type="html"><![CDATA[<p>注： 文中示例信息来自istio官方book示例.</p><p>istio中的边车代理envoy会拦截到两类流量:<br>1) 入流量: 其他Pod访问当前Pod中业务服务的流量。入流量访问的集群以inbound开头命名:<br>   inbound|9080|v1|ratings.default.svc.cluster.local<br>2) 出流量: 当前Pod中业务服务访问其他服务的流量,包括其他POD中的业务服务和istio系统相关的服务。入流量访问的集群命名以outbound开头: outbound|9080|v1|ratings.default.svc.cluster.local</p><p>入流量的上游集群比较简单，一般只有一个：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"hosts": [</span><br><span class="line">               &#123;</span><br><span class="line">                        <span class="attr">"socket_address"</span>: &#123;</span><br><span class="line">                        <span class="attr">"address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">                        <span class="attr">"port_value"</span>: <span class="number">9080</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">         ]</span><br></pre></td></tr></table></figure></p><p>这个Endpoint(127.0.0.1:9080)指向本地服务。出流量的上游集群包括所有的服务集群，因为当前POD的本地服务有访问任何服务的可能。</p><p>Envoy代理拦截到出流量之后,会根据被访问service的域名，URL等相关信息定位到特定的路由，然后到特定的集群，再按集群内部的负载算法获取特定的Endpoint地址，将流量发送给这个Endpoint。流量图大体如下：<br><img src="/2018/12/04/istio中的流量分析/in_out.png" alt="logo"><br>这个复杂的过程中,有两个重要的参数:<br>1) litener.use_original_dst:<br>如果采有iptables重定向连接, 那么envoy接受连接的监听端口与请求连接的原始目的地址是不同的。如果listener该属性设置为true，该listener将接收到的连接转交给符合请求原始地址的Listener。(透明代理获取原始地址?)由新的listener接受和处理该连接请求。前一个Listener相当于只分发连接。在istio中，这个Listener命名为命virtual。到达envoy的流量统一重定向到virtual listener中(监听地址为0.0.0.0:15001)，由它来选择合适的Listener处理流量。</p><p>2) litener.bind_to_port<br>这个属性在api-v2中找不到了，也没找到新替代者的说明。在istio 1.0版本中仍然使用他，但标记已过期。该属性表示Listener是否绑定主机端口。那么不绑定的端口的Listener，如何接受流量？是由标识use_original_dst的Listener(上文中的virtual Listener)接受流量，并转发给他。0.0.0.0_9080和10.244.2.20_9080都是bind_to_port为false的Listener,等待virtual listener分发的流量。0.0.0.0_9080接收所有9080端口的出流量，10.244.2.20_9080接受入流量。<br><img src="/2018/12/04/istio中的流量分析/netstat.png" alt="logo"><br>9080本地服务的端口，15000是envoy代理的管理端口，0.0.0.0:15001就是virtual listener的监听地址，envoy用来接收流量。在evnoy的配置中看到其他listener都没有绑定端口。</p><p>Note:<br>获取envoy全配置的方法:<br>kubectl exec productpage-v1-f5fcbd489-s7tfz -c istio-proxy – curl <a href="http://127.0.0.1:15000/config_dump" target="_blank" rel="noopener">http://127.0.0.1:15000/config_dump</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注： 文中示例信息来自istio官方book示例.&lt;/p&gt;
&lt;p&gt;istio中的边车代理envoy会拦截到两类流量:&lt;br&gt;1) 入流量: 其他Pod访问当前Pod中业务服务的流量。入流量访问的集群以inbound开头命名:&lt;br&gt;   inbound|9080|v1|ra
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CPU主频与MIPS</title>
    <link href="https://guojjanjun.github.io/2018/11/26/CPU%E4%B8%BB%E9%A2%91%E4%B8%8EMIPS/"/>
    <id>https://guojjanjun.github.io/2018/11/26/CPU主频与MIPS/</id>
    <published>2018-11-26T08:52:47.000Z</published>
    <updated>2018-12-21T05:37:41.052Z</updated>
    
    <content type="html"><![CDATA[<p>今天在一台龙芯CPU的机器上发现一个BogoMIPS参数，刚好位于CPU MHZ参数的上面:<br>BogoMIPS: 1593.34<br>cpu MHZ :  799.58<br>查看其他机器如redhat，ft等都有这两个参数,只是不放在一起，所认平时很难注意到。<br>MIPS Google描述为：Million Instructions Per Second，即每秒执行百万(M)指令数。这就奇怪了，当前CPU的主频才799.58MHZ，却可以每秒执行1593.34M个指令。相当每个时钟周期执行两个指令。</p><p>时钟周期是CPU主频的倒数，799.58MHZ表示每秒运行799.58百万个时钟周期. 而每执一个计算机指令都需要1至几十个时钟周期。一个指令的执行包括以下步骤：<br>1）指令预取<br>2）指令解码<br>3）执行<br>4）内存访问<br>5) 寄存器写回<br>最后两步是可选的，取决于指令本身。这里每一步都需要至少一个时钟周期来完成。那么一个指令至少需要3个时钟周期来完成? 这里CPU通过流水线技术同时执行不同指令的不同部分，提高CPU的吞吐量。上面的每一步都由CPU的一个功能组件来完成,当指令解码组件执行指令A的指令解码动作时，指令预取组件可以执行指令B的指令预取部分。最理想情况下，一个指令只需要一个时间周期。但仍然不能2倍主频？</p><p>部分资料提到指令宽度的概念，即上面所说的每一个功能单元组件有多个，一般3-4个。他们可以同时执行。这样最理想情况，一个指令只需要一个1/3或1/4个时间周期了。如果是这样的话，上面的情况就可以解释了。另外业内经常提到的IPC(或CPI)，即每指令周期数，在这里应该就是: CPI = MHZ/MIPS。从上面分析来看，CPI是可以小于1的。这里只是一个合理解释，不一定正确，期待指正。<br>参考：<br><a href="https://courses.cs.washington.edu/courses/cse471/07sp/lectures/Lecture3.pdf" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse471/07sp/lectures/Lecture3.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在一台龙芯CPU的机器上发现一个BogoMIPS参数，刚好位于CPU MHZ参数的上面:&lt;br&gt;BogoMIPS: 1593.34&lt;br&gt;cpu MHZ :  799.58&lt;br&gt;查看其他机器如redhat，ft等都有这两个参数,只是不放在一起，所认平时很难注意到。&lt;b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象众生相</title>
    <link href="https://guojjanjun.github.io/2018/11/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BC%97%E7%94%9F%E7%9B%B8/"/>
    <id>https://guojjanjun.github.io/2018/11/22/面向对象众生相/</id>
    <published>2018-11-22T11:35:36.000Z</published>
    <updated>2018-12-21T05:31:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>编程语言层出不穷，面向对象的样式各有特色。各种意料之外的编程模型，惊呼”哦,面象对象还可以这样玩”。其中比较容易理解的是Java和C++的对象模型，两者之间区分度也很小: Java的成员函数只能在类内定义, 而C++的成员函数可以类内声明，类外定义。(当然区分并不止这么点)。</p><p>后起之秀Go语言对面向对象有了新的定义: 面向对象就是将要处理的数据跟函数进行绑定的方法。</p><h3 id="定义数据类型："><a href="#定义数据类型：" class="headerlink" title="定义数据类型："></a>定义数据类型：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Dog struct&#123;</span><br><span class="line">   name string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定函数："><a href="#绑定函数：" class="headerlink" title="绑定函数："></a>绑定函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (dog Dog) move() &#123;</span><br><span class="line">   fmt.Println(dog.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用函数："><a href="#调用函数：" class="headerlink" title="调用函数："></a>调用函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   var aDog Dog</span><br><span class="line">   aDog.move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要为函数指定接收者,即完成了数据与函数的绑定,而且接收者可以是基础类型,比如int等。可以做到一切皆对象。自由绑定成员函数，使项目功能扩展极其方便。</p><p>起初笔者并不喜欢Javascript面向对象的方法，go的出现再次重申了Javascript面向对象的终极地位。且看Javascript几种创建对象的神技:</p><h3 id="方法一：通过Object对象"><a href="#方法一：通过Object对象" class="headerlink" title="方法一：通过Object对象"></a>方法一：通过Object对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var box = <span class="keyword">new</span> Object();</span><br><span class="line">box.name = <span class="string">'Lee'</span>;</span><br><span class="line">box.getName = function () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式与go倒有几分相似，不过Javascript不但能绑定函数，还可以增加数据成员。go语言并无出其右。</p><h3 id="方法二-构造函数式："><a href="#方法二-构造函数式：" class="headerlink" title="方法二: 构造函数式："></a>方法二: 构造函数式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Box</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.getName = function () &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var box1 = <span class="keyword">new</span> Box(<span class="string">'Lee'</span>)</span><br></pre></td></tr></table></figure><h3 id="方法三：原型模式"><a href="#方法三：原型模式" class="headerlink" title="方法三：原型模式"></a>方法三：原型模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Box.prototype.name = <span class="string">'Lee'</span>;</span><br><span class="line">Box.prototype.getName = function () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法四,五…, 招式只局限于你的想象力。为什么Javascript要搞这么复杂, 搞这么复杂…?</p><p>其实是Javascript玩了个七十二变的戏法, 让我们产生了错觉。下面来拆解Javascript这种怪异的OOP玩法？ </p><p>对于方法一, Object也是一个函数(typeof Object == function), 这个函数是Javascript内置的，不需要程序员重新定义。那它和方法二之间的相同基因就不难理解了。</p><p>方法一中Javascript可以为对象本身增加属性和绑定方法。方法二也是一样, 而this就是这个对象, 函数为this对象增加属性和绑定方法。再看方法三的模式, 同方法一、二并无不同, 只不过Box.prototype才是这个对象。</p><p>其实Javascript中每一个函数都有一个本尊(原型)对象，函数用这个对象作为创建新对象的基础对象, 我们把这个对象看成是具有变化能力的齐天大圣, 新对象都是大圣变化而来。这个本尊对象就是funcation_name.prototype。</p><p>而函数就是这位本尊的变身大法，也就是克隆出新对象的构造器, 启动变身大法（new 函数)本尊就会变成想要的模样。这样方法二就容易理解了。</p><p>对于方法三, Box.prototype就是Box函数的本尊，改变Box.prototype：Box.prototype.name = ‘Lee’。相当于改变了函数的本尊(原型)对象（由原来的孙悟空变成猪悟能), 构造器的当然就是在这个新本尊的基础上构建新对象。</p><p>更有意思的，方法二可以直接作为普通函数调用: Box(‘Lee’)，也可以作为构造函数调用 var box1 = new Box(‘Lee’)。函数里的this代表的对象什么不同呢？作为构造函数时，前面已经说过，这里不再重述。但作为普通函数，this却是当前Window对象，这里相当于window.Box(“Lee”)，即它是作为Window的成员函数而存在的。Javascript中所有的全局函数和对象都属于Window对象的属性和方法。</p><p>网上有很多Javascript面向对象的方法变体，用此方法，即可解疑惑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编程语言层出不穷，面向对象的样式各有特色。各种意料之外的编程模型，惊呼”哦,面象对象还可以这样玩”。其中比较容易理解的是Java和C++的对象模型，两者之间区分度也很小: Java的成员函数只能在类内定义, 而C++的成员函数可以类内声明，类外定义。(当然区分并不止这么点)
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一次现场问题的网络分析</title>
    <link href="https://guojjanjun.github.io/2018/11/16/%E4%B8%80%E6%AC%A1%E7%8E%B0%E5%9C%BA%E9%97%AE%E9%A2%98%E7%9A%84%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/"/>
    <id>https://guojjanjun.github.io/2018/11/16/一次现场问题的网络分析/</id>
    <published>2018-11-16T09:06:04.000Z</published>
    <updated>2018-12-21T05:33:47.488Z</updated>
    
    <content type="html"><![CDATA[<p>现场BES(应用服务器)连接Oracle总是很慢，特别是初始化连接时，经常出现创建连接超时。Oracle服务监听在ipv6地址上，端口1521。服务端为两台服务器组成的RAC集群。IP地址分别为2409:8018:5c00:201::208,<br>2409:8018:5c00:201::209。<br>从java的调用栈来看，只能看到hang在连接Oracle的调用栈上。目前没有其他好办法，只能抓个包试试看：<br><img src="/2018/11/16/一次现场问题的网络分析/0.png" alt="logo"><br>前三个包为连接x208的三次握手，接着Oracle drive发了一个Request,Connect包。我们先看1号包:<br><img src="/2018/11/16/一次现场问题的网络分析/1.png" alt="logo"><br>目的地址为x208,客户端将报文发送给Mac为00:0c:bd:08:46:15的设备, 看不出什么异常。继续看2号包：<br><img src="/2018/11/16/一次现场问题的网络分析/2.png" alt="logo"><br>信息来了，2号包却是一个MAC地址为e4:a8:b6:f6:95:12(Wireshark识别出为HuaweiTe) 的设备发出来的。因为远程协助，对方对环境等各方面不太清楚，不知道MAC地址为e4:a8:b6:f6:95:12的是个什么设备。但这里1号包与2号包走的不是一条线。而且Hop limit为61,那x208到客户端(也有可能根本没到x208)的应该经历了三(64-61)次路由转发。猜测客户端到208的拓扑应该是这样：<br><img src="/2018/11/16/一次现场问题的网络分析/t1.png" alt="logo"><br>继续向下看，发现能够正常通信的是发送到209的报文(第一个连接不成功，RAC切换到了第二个服务器)。23，24，25号包是与x209进行三次握手。<br><img src="/2018/11/16/一次现场问题的网络分析/23.png" alt="logo"><br>发现23号也是发送到MAC为00:0c:bd:08:46:15的设备上，那00:0c:bd:08:46:15肯定不是208或209的MAC,这里猜测00:0c:bd:08:46:15是客户端的网关路由器。服务器208，209都在路由器后面。再看24号包:<br><img src="/2018/11/16/一次现场问题的网络分析/24.png" alt="logo"><br>24号包也是由设备e4:a8:b6:f6:95:12发出。以及正常通信的26,27号包:<br><img src="/2018/11/16/一次现场问题的网络分析/26.png" alt="logo"><br><img src="/2018/11/16/一次现场问题的网络分析/27.png" alt="logo"><br>都是：32:09:be:88:d8:67 -&gt; 00:0c:bd:08:46:15,e4:a8:b6:f6:95:12-&gt;32:09:be:88:d8:67。说明服务器返回到客户端的报文最终都由e4:a8:b6:f6:95:12设备转发一次。猜测e4:a8:b6:f6:95:12<br>很可能是一个firewall设备，拓拆接近下图：<br><img src="/2018/11/16/一次现场问题的网络分析/t2.png" alt="logo"><br>没有现场环境，只能猜到这些。已告知对方检测e4:a8:b6:f6:95:12设备对x208与x209的路由的情况.由于对网络拓扑接触的比较少，还望大家给予指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现场BES(应用服务器)连接Oracle总是很慢，特别是初始化连接时，经常出现创建连接超时。Oracle服务监听在ipv6地址上，端口1521。服务端为两台服务器组成的RAC集群。IP地址分别为2409:8018:5c00:201::208,&lt;br&gt;2409:8018:5c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VMWare网络不通一个可能原因分析</title>
    <link href="https://guojjanjun.github.io/2018/11/08/VMWare%E7%BD%91%E7%BB%9C%E4%B8%8D%E9%80%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    <id>https://guojjanjun.github.io/2018/11/08/VMWare网络不通一个可能原因分析/</id>
    <published>2018-11-08T10:00:59.000Z</published>
    <updated>2018-11-08T11:55:16.909Z</updated>
    
    <content type="html"><![CDATA[<p>今天配置VMWare网络，感觉一切都OK, 但就是Ping不通主机。发现问题的原因在于在虚拟网络编辑器<br>(Edit &gt; Virtual Network Settings）里桥接网络绑定是VMnet8:<br><img src="/2018/11/08/VMWare网络不通一个可能原因分析/NetSet.png" alt="logo"><br>改成VMNet0，立马可以Ping通。难道桥接模式只能绑定到VMNet0? 难道VMNet(0-N)与网络<br>模式一一对应，这不现实呀，3种网格模式不可能对应0-N个虚拟设备。不扯了，直接上结论吧。<br>吧。</p><p>其实VMNet0,VMNet1,VMNet8默认分别对应桥接模式，主机模式和Nat模式。而且可以更改对应关系。<br>更改的位置就是上面提到虚拟网络编辑器(Virtual Network Settings)。但不通原因并不在这，而<br>在于虚拟机设置页面:<br><img src="/2018/11/08/VMWare网络不通一个可能原因分析/Vmset.png" alt="logo"><br>我们看到Bridged,Nat,Host-only,和custom四种模式，选择custom时，需要指定绑定的虚拟设备，而<br>选择其他模式时，不用选择虚拟设备，但是(重点来了)选择Bridged,Nat,Host-only这三种模式时，<br>却默认分别绑定到VMNet0,VMNet1,VMNet8三种设备上，也就是说这种选择VM workstation已经内定了。<br>你可以选择custom方式，使得网卡桥接到其他设备上，否则他就是桥接到VMNet0。如果你的虚拟网络编辑<br>器里只配了VMNet8为桥接模式（本人当时的环境即如此），则当然无法Ping通了。</p><p>所以真正决定的网卡的网络模型的，是虚拟网络编辑器里的对于虚拟设备的设置，而虚拟机设置页面对虚机网<br>卡的设置只起绑定作用, 不要被文字蒙蔽了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天配置VMWare网络，感觉一切都OK, 但就是Ping不通主机。发现问题的原因在于在虚拟网络编辑器&lt;br&gt;(Edit &amp;gt; Virtual Network Settings）里桥接网络绑定是VMnet8:&lt;br&gt;&lt;img src=&quot;/2018/11/08/VMWar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程模型</title>
    <link href="https://guojjanjun.github.io/2018/10/17/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>https://guojjanjun.github.io/2018/10/17/线程模型/</id>
    <published>2018-10-17T09:17:39.000Z</published>
    <updated>2018-12-21T05:30:27.912Z</updated>
    
    <content type="html"><![CDATA[<p>最近阅读&lt;现代操作系统&gt;时，讲到线程根据其存在的位置分为用户级线程和内核级线程。用户级线程存在于用户空间中，他的创建，销毁，调度都由用户空间的线程库来完成。操作系统内核无法感知上层线程的切换。操作系统像不存在多线程一样去作进程调度。内核级线程存在于内核空间中,由操作系统内核创建和管理。用户程序创建的内核线程通过system call创建内核级线程.</p><p>用户级线程可以在不支持内核线程的系统上实现多线程编程。现代操作系统绝大数都支持内核线程,所以实现方式集在用户级线程和内核级线程的混用方式。更多优缺点，请参考&lt;现代操作系统&gt;原文。</p><p>在操作系统概念到提到用户线线程与内核级线程存在三种对应关系：</p><h3 id="1-多对一"><a href="#1-多对一" class="headerlink" title="1. 多对一"></a>1. 多对一</h3><p>多个用户线程对应一个内核线程。这其实就是纯用户级多线程的实现方式。如果一个线程执行阻塞的系统调用，会导致当前进程被内核调度出去，其他线程也无法执行。任意时刻只能有一个线程访问内核，且多个线程无法调度在多个CPU上,因为他们在内核中的调度单元是进程。腾讯libco框架单个线程上实现多个协程的并发运行。<a href="https://blog.csdn.net/chdhust/article/details/53271478" target="_blank" rel="noopener">https://blog.csdn.net/chdhust/article/details/53271478</a></p><h3 id="2-一对一"><a href="#2-一对一" class="headerlink" title="2. 一对一"></a>2. 一对一</h3><p>一个用户线程对应一个内核线程。线程的调度由内核线程的调度来完成。如果一个线程执行阻塞的系统调用，另一个线程会被切换执行,且多个线程可以运行在多个CPU上。比如Java在Linux、windows上的实现,一个java线程通过LWP与一个系统内核线程绑定。缺点，内核线程的数量限制限制了用户线程的数量。</p><h3 id="3-多对多"><a href="#3-多对多" class="headerlink" title="3. 多对多"></a>3. 多对多</h3><p>多个用户线程对应多个内核线程，一般用户线程数大于内核线程数.这种模式不但有一对一的并发性能，而且解决了用户线程数量的限制问题。这种模型又称为二级模型，HP-UX等支持。Solaris9之后采有一对一模型.</p><p>参考：<br><a href="https://www.cnblogs.com/zengkefu/p/5589876.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengkefu/p/5589876.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近阅读&amp;lt;现代操作系统&amp;gt;时，讲到线程根据其存在的位置分为用户级线程和内核级线程。用户级线程存在于用户空间中，他的创建，销毁，调度都由用户空间的线程库来完成。操作系统内核无法感知上层线程的切换。操作系统像不存在多线程一样去作进程调度。内核级线程存在于内核空间中,由
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://guojjanjun.github.io/2018/09/30/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://guojjanjun.github.io/2018/09/30/红黑树/</id>
    <published>2018-09-30T03:36:42.000Z</published>
    <updated>2018-09-30T03:38:59.803Z</updated>
    
    <content type="html"><![CDATA[<p>这个博客讲得很详细：<a href="https://blog.csdn.net/johnny901114/article/details/81046088" target="_blank" rel="noopener">https://blog.csdn.net/johnny901114/article/details/81046088</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个博客讲得很详细：&lt;a href=&quot;https://blog.csdn.net/johnny901114/article/details/81046088&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/john
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程栈中的锁信息</title>
    <link href="https://guojjanjun.github.io/2018/09/26/Java%E7%BA%BF%E7%A8%8B%E6%A0%88%E4%B8%AD%E7%9A%84%E9%94%81%E4%BF%A1%E6%81%AF/"/>
    <id>https://guojjanjun.github.io/2018/09/26/Java线程栈中的锁信息/</id>
    <published>2018-09-26T12:22:04.000Z</published>
    <updated>2018-09-27T03:05:58.904Z</updated>
    
    <content type="html"><![CDATA[<p>  分析运行时Java应用性能问题或死锁问题时，获取线程栈中锁信息是最基本的手段。JDK5.0之后加锁存在两种方法：1.Jvm内置的synchronized 2. Java并发包中相关同步类。本篇主要讨论线程栈中表现出来的锁的信息，对于我们分析Java性能或死锁提供哪些线索。</p><h3 id="情况1-Object-wait-Object-wait-int-timeout"><a href="#情况1-Object-wait-Object-wait-int-timeout" class="headerlink" title="情况1:  Object.wait()/ Object.wait(int timeout)"></a>情况1:  Object.wait()/ Object.wait(int timeout)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeWait</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object scarce = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncWaiter(scarce));</span><br><span class="line">        t.setName(<span class="string">"Test-Thread-1"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncWaiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   privateObject scarce;</span><br><span class="line">   publicSyncWaiter(Object scarce)&#123;</span><br><span class="line">      <span class="keyword">this</span>.scarce = scarce;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   publicvoidrun() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (scarce) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                scarce.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"Test-Thread-1" #10 prio=5os_prio=0 tid=0x0000000058709800 nid=0x1d14 in Object.wait() [0x000000005930f000]</span><br><span class="line">  java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">       at java.lang.Object.wait(Native Method)</span><br><span class="line">       - waiting on &lt;<span class="number">0x00000000d7ac6058</span>&gt;(a java.lang.Object)</span><br><span class="line">       at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">       at org.guojje.SyncWaiter.run(InvokeWait.java:<span class="number">23</span>)</span><br><span class="line">       - locked &lt;<span class="number">0x00000000d7ac6058</span>&gt; (ajava.lang.Object)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>这种情况下，线程处于WAITING状态，等待获取对象锁，该线程必须先锁定了该对象(即进入synchronized区域)，才可以调用wait方法(画重点)，并在调用wait方法后释放对象锁，并进入对象锁Wait Set队列等待被唤醒。WAITING状态的线程必须有对应的notify唤醒。这与后面遇到Blocked状态的线程不同，Blocked是不需要唤醒的。<br>备注：<br>     1) 每一个Java对象与生俱来带有唯一一把对象锁(叫Intrinsic lock或Monitor)。<br>      2) (a java.lang.Object)表示资源的类名，这里为一个Object对象。<br>      3) 当调用带有时间参数的Wait方法，这时线程状态显示TIMED_WAITING。<br>      4）Wait Set队列与下面的Entry Set队列的含义，可自行Google。</p><h3 id="情况2-资源争用"><a href="#情况2-资源争用" class="headerlink" title="情况2: 资源争用"></a>情况2: 资源争用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Share</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">     Object scarce = <span class="keyword">new</span> Object();</span><br><span class="line">     Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncLock2(scarce));</span><br><span class="line">     thread.setName(<span class="string">"Test-thrad-1"</span>);</span><br><span class="line">     Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncLock2(scarce));</span><br><span class="line">     thread2.setName(<span class="string">"Test-thrad-2"</span>);</span><br><span class="line">     thread.start();</span><br><span class="line">     thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Object scarce;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SyncLock2</span><span class="params">(Object scarce)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.scarce = scarce;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (scarce) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             System.in.read();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"Test-thrad-2" #11 prio=5os_prio=0 tid=0x0000000058a09000 nid=0x1c94 waiting for monitor entry [0x00000000595af000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">       at org.guojje.SyncLock2.run(Share.java:<span class="number">28</span>)</span><br><span class="line">       - waiting to lock &lt;<span class="number">0x00000000d7ac5f48</span>&gt;(a java.lang.Object)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">"Test-thrad-1" #10 prio=5os_prio=0 tid=0x0000000058a08800 nid=0x1eb8 runnable [0x00000000596ce000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line">       at java.io.FileInputStream.readBytes(Native Method)</span><br><span class="line">       at java.io.FileInputStream.read(FileInputStream.java:<span class="number">246</span>)</span><br><span class="line">       at java.io.BufferedInputStream.fill(BufferedInputStream.java:<span class="number">246</span>)</span><br><span class="line">       at java.io.BufferedInputStream.read(BufferedInputStream.java:<span class="number">265</span>)</span><br><span class="line">       - locked &lt;<span class="number">0x00000000d79d8d38</span>&gt; (ajava.io.BufferedInputStream)</span><br><span class="line">       at org.guojje.SyncLock2.run(Share.java:<span class="number">28</span>)</span><br><span class="line">       - locked &lt;<span class="number">0x00000000d7ac5f48</span>&gt; (a java.lang.Object)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>Test-thrad-2处于BLOCKED状态，说明线程Test-thrad-2进入synchronized临界区, 进入对象锁的Entry Set队列并等待对象锁0x00000000d79d8d38的释放。通过定位locked <0x00000000d79d8d38>，我们很容易发现哪个线程正在占用这把锁。在性能分析过程，如果发现大量的BLOCKED线程，我们就需要分析谁当前持有这把锁，而且长时间没有释放。 通过locked指示的代码行，我们很容易定位到加锁位置。然后进行降低锁粒度等手段，减少线程加锁的持续时间，从而优化性能。</0x00000000d79d8d38></p><h3 id="情况3-死锁"><a href="#情况3-死锁" class="headerlink" title="情况3 死锁"></a>情况3 死锁</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object scarce = <span class="keyword">new</span> Object();</span><br><span class="line">        Object scarce2 = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock(scarce, scarce2));</span><br><span class="line">        thread.setName(<span class="string">"Test-thrad-1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock(scarce2, scarce));</span><br><span class="line">        thread2.setName(<span class="string">"Test-thrad-2"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Object scarce;</span><br><span class="line">   <span class="keyword">private</span> Object scarce2;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">(Object scarce,Object scarce2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scarce = scarce;</span><br><span class="line">        <span class="keyword">this</span>.scarce2 = scarce2;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (scarce) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (scarce2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">443</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"Test-thrad-2" #11 prio=5 os_prio=0tid=0x00000000185c7800 nid=0x2b88 waiting for monitor entry [0x00000000196bf000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">       at org.guojje.DeadLock.run(DeadLock.java:<span class="number">21</span>)</span><br><span class="line">       - waiting to lock &lt;<span class="number">0x00000000d7ac5e90</span>&gt;(a java.lang.Object)</span><br><span class="line">       - locked &lt;<span class="number">0x00000000d7ac5ea0</span>&gt;(a java.lang.Object)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">"Test-thrad-1" #10 prio=5os_prio=0 tid=0x00000000185c2800 nid=0x281c waiting for monitor entry [0x00000000194bf000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">      at org.guojje.DeadLock.run(DeadLock.java:<span class="number">21</span>)</span><br><span class="line">      - waiting to lock &lt;<span class="number">0x00000000d7ac5ea0</span>&gt;(a java.lang.Object)</span><br><span class="line">      - locked &lt;<span class="number">0x00000000d7ac5e90</span>&gt; (ajava.lang.Object)</span><br><span class="line">      at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>Test-thrad-2线程拿到了0x00000000d7ac5ea0锁，在等待x00000000d7ac5e90锁，而Test-thrad-1刚好相反，发生了死锁的条件, 而且从线程栈很容易定位这些锁是在哪一行代码获取的，且又在哪一行代码阻塞的。JVM线程栈信息的尾端提供了更详细的死锁环的信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Test-thrad-2"</span>:</span><br><span class="line"> waiting to lock monitor <span class="number">0x0000000017235028</span> (object <span class="number">0x00000000d7ac5e90</span>, a java.lang.Object),</span><br><span class="line"> which is held by <span class="string">"Test-thrad-1"</span></span><br><span class="line"><span class="string">"Test-thrad-1"</span>:</span><br><span class="line"> waiting to lock monitor <span class="number">0x00000000172350d8</span> (object <span class="number">0x00000000d7ac5ea0</span>, a java.lang.Object),</span><br><span class="line"> which is held by <span class="string">"Test-thrad-2"</span></span><br><span class="line">Java stack information <span class="keyword">for</span> the threadslisted above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Test-thrad-2"</span>:</span><br><span class="line">       at org.guojje.DeadLock.run(DeadLock.java:<span class="number">21</span>)</span><br><span class="line">       - waiting to lock &lt;<span class="number">0x00000000d7ac5e90</span>&gt;(a java.lang.Object)</span><br><span class="line">       - locked &lt;<span class="number">0x00000000d7ac5ea0</span>&gt;(a java.lang.Object)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="string">"Test-thrad-1"</span>:</span><br><span class="line">       at org.guojje.DeadLock.run(DeadLock.java:<span class="number">21</span>)</span><br><span class="line">       - waiting to lock &lt;<span class="number">0x00000000d7ac5ea0</span>&gt;(a java.lang.Object)</span><br><span class="line">       - locked &lt;<span class="number">0x00000000d7ac5e90</span>&gt; (a java.lang.Object)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure></p><p>你会发现JDK内置的synchronized加锁方式，你会发现问题分析死锁问题非常容易。这个例子就是因为竞争线程对资源的加锁顺序不同，导致死锁。而保持相同的加锁顺序是解决这类死锁问题关健。<br>对于内置的synchronized的同步方式，线程栈提供了足够的信息让我们分析与定位问题。但synchronized不够灵活等，使Java并发包更受程序序员青睐，但同时也为分析这类问题代来复杂性。</p><h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><p>同样，我们先看一个ReentrantLock（重入锁的）await方法(与Ojbect.wait区别开来)的调用情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RTLock());</span><br><span class="line">        thread.setName(<span class="string">"Test-thrad-1"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ReentrantLock lock= newReentrantLock();</span><br><span class="line">   <span class="keyword">public</span> Condition scarce= lock.newCondition();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RTLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            scarce.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"Test-thrad-1" #10 prio=5os_prio=0 tid=0x00000000189d0800 nid=0x2da8 waiting on condition [0x000000001968e000]</span><br><span class="line">  java.lang.Thread.State: WAITING (parking)</span><br><span class="line">       at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">       - parkingto wait <span class="keyword">for</span>  &lt;<span class="number">0x00000000d7ac9088</span>&gt;(a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">       at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">       at com.guojje2.RTLock.run(RTLock.java:<span class="number">18</span>)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>显示与synchronized有些不同。Synchronized显示为Wait on，这里- parking to wait for。<br>另外可以发现调用栈再也找不到locked字眼了,虽然你确认该线程一定locked过这把锁（否则无法调用await）。因为这个原因，为定位加锁位置带来难度。</p><h3 id="情况2-资源争用-1"><a href="#情况2-资源争用-1" class="headerlink" title="情况2 资源争用"></a>情况2 资源争用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RTLock(lock));</span><br><span class="line">        thread.setName(<span class="string">"Test-thrad-1"</span>);</span><br><span class="line">        Thread thread2 =  <span class="keyword">new</span> Thread(<span class="keyword">new</span> RTLock(lock));</span><br><span class="line">        thread2.setName(<span class="string">"Test-thrad-2"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RTLock</span><span class="params">(ReentrantLock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">"Test-thrad-2" #11 prio=5os_prio=0 tid=0x0000000018802000 nid=0x3368 waiting on condition [0x000000001965f000]</span><br><span class="line">  java.lang.Thread.State: WAITING (parking)</span><br><span class="line">       at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">       - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000000d7ac72a8</span>&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">       at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:<span class="number">836</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:<span class="number">870</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:<span class="number">1199</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:<span class="number">209</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:<span class="number">285</span>)</span><br><span class="line">        at com.guojje2.RTLock.run(Main.java:<span class="number">33</span>)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">Locked ownable synchronizers:</span><br><span class="line">    - None</span><br><span class="line">"Test-thrad-1" #10 prio=5os_prio=0 tid=0x0000000018801800 nid=0x2d3c runnable [0x000000001933f000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line">       at java.io.FileInputStream.readBytes(Native Method)</span><br><span class="line">       at java.io.FileInputStream.read(FileInputStream.java:<span class="number">246</span>)</span><br><span class="line">       at java.io.BufferedInputStream.fill(BufferedInputStream.java:<span class="number">246</span>)</span><br><span class="line">       at java.io.BufferedInputStream.read(BufferedInputStream.java:<span class="number">265</span>)</span><br><span class="line">       - locked &lt;<span class="number">0x00000000d79d8d38</span>&gt; (a java.io.BufferedInputStream)</span><br><span class="line">       at com.guojje2.RTLock.run(Main.java:<span class="number">35</span>)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">  Locked ownable synchronizers:</span><br><span class="line">       - &lt;<span class="number">0x00000000d7ac72a8</span>&gt; (ajava.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br></pre></td></tr></table></figure><p>如果是synchronized的方式，Test-thrad-2线程应该是Blocked状态，但这里为WAITING。这也是内置锁与JUL锁的不同。<br>注： 只要看Blocked状态的线程，代码一定是用synchronized作的同步。<br>在线程栈中多出了Locked ownable synchronizers条目。这是用jstack-l打印出来。（-l表示打印更详细的栈信息）。Java已经做了努力，弥补线程栈没有locked信息的缺陷。假如没有这个条目，无法确认Test-thrad-2等待的锁被哪一个线程持有。即便如此，还是无法定位加锁的代码位置，目前本人并没有找到更好的方法，只能翻代码了。<br>Ownable synchronizers这里的ownable的可以理解为，可被霸占的，即抢到就只属于你的。（有的邪恶哦？）<br>所以Locked ownable synchronizers只会列出排他锁，如ReentrantLock锁和ReentrantReadWriteLock的写锁，而对于ReentrantReadWriteLock读是不会显示的。因为他不算排他锁(ownable)。某些情况下，这一点也为定位问题加在难度。<br>注：- locked <0x00000000d79d8d38> (a java.io.BufferedInputStream)是BufferedInputStream.read上的锁不要搞混.</0x00000000d79d8d38></p><h3 id="情况3-死锁-1"><a href="#情况3-死锁-1" class="headerlink" title="情况3 死锁"></a>情况3 死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RTLock(lock, lock2));</span><br><span class="line">       thread.setName(<span class="string">"Test-thrad-1"</span>);</span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RTLock(lock2, lock));</span><br><span class="line">       thread2.setName(<span class="string">"Test-thrad-2"</span>);</span><br><span class="line">       thread.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">   <span class="keyword">private</span> ReentrantLock lock2;</span><br><span class="line">   publicRTLock(ReentrantLock lock, ReentrantLock lock2) &#123;</span><br><span class="line">       <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.lock2 = lock2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock2.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">"Test-thrad-2" #11 prio=5os_prio=0 tid=0x0000000018871000 nid=0x2588 waiting on condition [0x00000000198ef000]</span><br><span class="line">  java.lang.Thread.State: WAITING (parking)</span><br><span class="line">       at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">       - parking to wait <span class="keyword">for</span> &lt;<span class="number">0x00000000d7ac7388</span>&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">       at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:<span class="number">836</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:<span class="number">870</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:<span class="number">1199</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:<span class="number">209</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:<span class="number">285</span>)</span><br><span class="line">       at com.guojje2.RTLock.run(Main.java:<span class="number">35</span>)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">  Locked ownable synchronizers:</span><br><span class="line">       - &lt;<span class="number">0x00000000d7ac73b8</span>&gt; (ajava.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">"Test-thrad-1" #10 prio=5os_prio=0 tid=0x0000000018870000 nid=0x2fb0 waiting on condition [0x00000000184ae000]</span><br><span class="line">  java.lang.Thread.State: WAITING (parking)</span><br><span class="line">       at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">       - parking to wait <span class="keyword">for</span> &lt;<span class="number">0x00000000d7ac73b8</span>&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">       at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:<span class="number">836</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:<span class="number">870</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:<span class="number">1199</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:<span class="number">209</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:<span class="number">285</span>)</span><br><span class="line">       at com.guojje2.RTLock.run(Main.java:<span class="number">35</span>)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"> Locked ownable synchronizers:</span><br><span class="line">       - &lt;<span class="number">0x00000000d7ac7388</span>&gt; (ajava.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Test-thrad-2"</span>:</span><br><span class="line"> waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x00000000d7ac71a0</span>,(a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line"> which is held by <span class="string">"Test-thrad-1"</span></span><br><span class="line"><span class="string">"Test-thrad-1"</span>:</span><br><span class="line"> waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x00000000d7ac71d0</span>, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line"> which is held by <span class="string">"Test-thrad-2"</span></span><br><span class="line">.</span><br><span class="line">Java stack information <span class="keyword">for</span> the threadslisted above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Test-thrad-2"</span>:</span><br><span class="line">       at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">       - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000000d7ac71a0</span>&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">       at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:<span class="number">836</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:<span class="number">870</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:<span class="number">1199</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:<span class="number">209</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:<span class="number">285</span>)</span><br><span class="line">       at com.guojje2.RTLock.run(Main.java:<span class="number">41</span>)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="string">"Test-thrad-1"</span>:</span><br><span class="line">       at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">       - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000000d7ac71d0</span>&gt; (ajava.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">       at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:<span class="number">836</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:<span class="number">870</span>)</span><br><span class="line">       at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:<span class="number">1199</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:<span class="number">209</span>)</span><br><span class="line">       at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:<span class="number">285</span>)</span><br><span class="line">       at com.guojje2.RTLock.run(Main.java:<span class="number">41</span>)</span><br><span class="line">       at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure><p>借助Locked ownable synchronizers，确认哪些线程位于死锁的环形竞争中，还是比较容易。先到这吧。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  分析运行时Java应用性能问题或死锁问题时，获取线程栈中锁信息是最基本的手段。JDK5.0之后加锁存在两种方法：1.Jvm内置的synchronized 2. Java并发包中相关同步类。本篇主要讨论线程栈中表现出来的锁的信息，对于我们分析Java性能或死锁提供哪些线索
      
    
    </summary>
    
    
  </entry>
  
</feed>
